<!DOCTYPE html>
<html><head><title>Protocol/Implementation summary</title><link href="http://yui.yahooapis.com/pure/0.2.0/pure-min.css" rel="stylesheet" type="text/css"><link href="http://netdna.bootstrapcdn.com/font-awesome/3.2.1/css/font-awesome.css" rel="stylesheet" type="text/css"></head><body style="padding: 0 2em;"><div class="pure-g"><div class="pure-u-1"><h2>Protocol/Implementation summary</h2><p>git hash: <a href="https://github.com/mikera/core.matrix/tree/"></a></p><small>Hint: hover on protocol or implementation names to get their description</small></div><div class="pure-u-1"><table class="pure-table"><thead><th></th><th><span>vectorz</span></th><th><span title="An implementation of strided N-Dimensional array">ndarray</span></th><th><span title="An implementation of strided N-Dimensional array">ndarray-double</span></th><th><span title="Implementation for nested Clojure persistent vectors used as matrices">persistent-vector</span></th><th><span title="Core.matrix implementation enabling a map with appropriate metadata to be used as a core.matrix implementation.">persistent-map</span></th><th><span title="Core.matrix implementation for Clojure ISeq objects">sequence</span></th><th><span title="Clojure.core.matrix implementation for Java double arrays">double-array</span></th><th><span title="Wraps a single scalar as a mutable 0-D array">scalar-wrapper</span></th><th><span title="Wraps a row-major slice of an array">slice-wrapper</span></th><th><span title="Wraps an N-dimensional subset or broadcast of an array">nd-wrapper</span></th><th><span title="clojure.core.matrix implementation for datasets">dataset</span></th><th><span>clatrix</span></th></thead><tbody><tr class="pure-table-odd"><td><span title="Protocol to support mathematic functions applied element-wise to a numerical array">PMathsFunctions</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure//tmp/form-init3107686982932593143.clj#L1">1</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol to support mutable mathematic functions applied element-wise to a numerical array">PMathsFunctionsMutable</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure//tmp/form-init3107686982932593143.clj#L1">1</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol for general implementation functionality. Required to support implementation metadata and matrix construction.">PImplementation</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L24">24</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td></tr><tr><td><span title="Protocol to return standard dimension information about an array. dimensionality and dimension-count are mandatory for implementations">PDimensionInfo</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L55">55</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td></tr><tr class="pure-table-odd"><td><span title="Protocol for indexed read access to arrays, matrices and vectors. Indexing values can be assumed to be integers. indexes may be any sequence or Java array of index values.">PIndexedAccess</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L75">75</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td></tr><tr><td><span title="Protocol for indexed &apos;setter&apos; operations. These are like Clojure&apos;s &apos;assoc&apos; function, i.e. they return an updated copy of the original array, which is itself unchanged. Must be supported for any immutable array type.">PIndexedSetting</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L82">82</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td></tr><tr class="pure-table-odd"><td><span title="Protocol for indexed mutable setter access to matrices and vectors. Must be supported for any mutable matrix type.">PIndexedSettingMutable</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L98">98</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for cloning a matrix value. The new clone must be mutable if the original matrix is mutable, i.e. mutating the clone must not affect the original. The copy should be shallow, if applicable.">PMatrixCloning</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L105">105</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td></tr><tr class="pure-table-odd"><td><span title="Protocol for querying the type of matrix elements. If not provided, the default implementation will return java.lang.Object, and the matrix object must accept any type of value. If a matrix is primitive-backed, it should return the appropriate primitive type e.g. Double/TYPE.">PTypeInfo</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L133">133</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td></tr><tr><td><span title="Option protocol for quick determination of array matrics">PArrayMetrics</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L139">139</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Optional protocol to validate the shape of a matrix. If the matrix has an incorrect shape, should throw an error. Otherwise it should return the correct shape.">PValidateShape</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L143">143</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol to support construction of row and column matrices from 1D vectors. A vector of length N should be converted to a 1xN or Nx1 matrix respectively. Should throw an error if the data is not a 1D vector">PRowColMatrix</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L148">148</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol for creating a mutable copy of a matrix. If implemented, must return either a fully mutable copy of the given matrix, or nil if not possible. The default implementation will attempt to choose a suitable mutable matrix implementation.">PMutableMatrixConstruction</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L157">157</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for constructing a sparse array from the given data. Implementations should consider the possibility that data may be a large lazy sequence, possibly larger than memory, so should ideally attempt to construct the sparse matrix incrementally without realising the whole sequence at once. May return nil if no sparse conversion is available.">PSparse</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L164">164</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol for constructing a dense array from the given data.">PDense</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L173">173</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for creating an immutable copy of a matrix. If implemented, must return a fully immutable copy of the given matrix. The default implementation will attempt to choose a suitable immutable matrix implementation.">PImmutableMatrixConstruction</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L178">178</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span>PZeroDimensionConstruction</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L185">185</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for accessing the scalar value in zero-dimensional arrays. Zero dimensional arrays differ from scalar values in the following two senses: - They may be mutable (in which case set-0d! is expected to work) - They are not considered themselves to be scalars. Hence you must use get-0d to access the contained scalar value">PZeroDimensionAccess</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L191">191</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol for setting the scalar value in zero-dimensional arrays.">PZeroDimensionSet</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L200">200</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for construction of special matrices.">PSpecialisedConstructors</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L204">204</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td></tr><tr class="pure-table-odd"><td><span title="Protocol for construction of a permutation matrix.">PPermutationMatrix</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L209">209</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for construction of a block diagonal matrix.">PBlockDiagonalMatrix</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L213">213</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol to coerce a parameter to a format used by a specific implementation. It is up to the implementation to determine what parameter types they support. If the implementation is unable to perform coercion, it must return nil. Implementations are encouraged to avoid taking a full copy of the data, for performance reasons. It is preferable to use structural sharing with the original data if possible. If coercion is impossible (e.g. param has an invalid shape or element types) then the implementation *may* throw an exception, though it may also return nil to get default behaviour, which should implement any expected exceptions. If an implementation implements coercion via copying, then it is recommended that conversion should be to the most efficient packed representation (i.e. as defined by &apos;pack&apos;) Implementations must also be able to coerce valid scalar values (presumably via the identity function)">PCoercion</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L217">217</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td></tr><tr><td><span title="Protocol to support broadcasting over one or more dimensions.">PBroadcast</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L237">237</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td></tr><tr class="pure-table-odd"><td><span title="Protocol to broadcast into a given matrix shape. May also perform coercion if needed by the implementation.">PBroadcastLike</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L251">251</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td></tr><tr><td><span title="Protocol to broadcast into a given matrix shape and perform coercion in one step. Equivalent to (coerce m (broadcast-like m a)) but likely to be more efficient.">PBroadcastCoerce</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L255">255</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol to allow conversion to Clojure-friendly vector format. Optional for implementers, however providing an efficient implementation is strongly encouraged to enable fast interop with Clojure vectors.">PConversion</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L261">261</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td></tr><tr><td><span title="Protocol to reshape matrices. Should support any new shape allowed by the implementation. Must preserve row-major ordering of matrix elements. If the original matrix is mutable, must return a new mutable copy of data. If the new shape has less elements than the original shape, it is OK to truncate the remaining elements. If the new shape requires more elements than the original shape, should throw an exception.">PReshaping</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L267">267</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol to efficiently pack an array, according to the most efficient representation for a given implementation. Definition of pack is up to the implementation to interpret, but the general rules are: 1. Must not change the value of the array for comparison purposes 2. Must not change the shape of the array 3. May preserve sparse representation 4. Should convert to most efficient format for common operations (e.g. mget, inner-product)">PPack</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L275">275</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol to test if two arrays have the same shape. Implementations may have an optimised method for shape equality tests, and this is a frequently required operations so it may make sense to provide an optimised implementation.">PSameShape</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L286">286</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol to support getting slices of an array. If implemented, must return either a view, a scalar or an immutable sub-matrix: it must *not* return copied data. i.e. making a full copy must be avoided.">PMatrixSlices</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L292">292</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td></tr><tr><td><span title="Protocol for accessing rows of a matrix">PMatrixRows</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L300">300</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol for accessing columns of a matrix">PMatrixColumns</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L304">304</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for quick view access into a row-major slices of an array. If implemented, must return either a view or an immutable sub-matrix: it must *not* return copied data. If the matrix is mutable, it must return a mutable view. The default implementation creates a wrapper view.">PSliceView</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L308">308</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td></tr><tr class="pure-table-odd"><td><span title="Returns the row-major slices of the array as a sequence. These must be views or immutable sub-arrays for higher order slices, or scalars for the slices of a 1D vector. The default implementation uses get-major-slice-view to obtain the slices.">PSliceSeq</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L317">317</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td></tr><tr><td><span title="Returns slices of the array as a sequence. These must be views or immutable sub-arrays for higher order slices, or scalars for the slices of a 1D vector.">PSliceSeq2</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L326">326</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Returns the row-major slice views of the array. These must be arrays if the array is mutable, i.e. slices of a 1D vector must be 0-dimensional mutable arrays.">PSliceViewSeq</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L333">333</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for concatenating / joining arrays.">PSliceJoin</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L340">340</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol for concatenating / joining arrays.">PSliceJoinAlong</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L344">344</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for getting a sub-vector view of a vector. Must return a mutable view if the original vector is mutable. Should throw an exception if the specified subvector is out of bounds for the target vector.">PSubVector</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L348">348</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol for picking out subsections of a 2D matrix. Should return a mutable view if possible. The default implementation creates a new vector containing the diagonal values.">PMatrixSubComponents</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L355">355</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for determining if an array is in a sparse format. It is up to the implementation to define its own sparse formats, but in general the intention should be that a sparse array uses significantly less storage than an equivalent dense array, assuming a high proportion of zero values in the array.">PSparseArray</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L360">360</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol for counting the number of zeros in an array">PZeroCount</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L366">366</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for assigning values element-wise to mutable arrays.">PAssignment</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L370">370</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol for assigning values element-wise to an array, broadcasting as needed.">PImmutableAssignment</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L381">381</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span>PMutableFill</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L388">388</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol for getting data as a double array">PDoubleArrayOutput</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L393">393</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for getting data as an object array">PObjectArrayOutput</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L402">402</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol for comparing two arrays, with the semantics of clojure.core/=. Returns false if the arrays are not of equal shape, or if any elements are not equal.">PValueEquality</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L411">411</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for numerical array equality operations.">PMatrixEquality</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L416">416</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td></tr><tr class="pure-table-odd"><td><span title="Protocol for numerical array equality operations with a specified tolerance.">PMatrixEqualityEpsilon</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L425">425</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol to support matrix multiplication on an arbitrary matrix, vector or scalar. Implementation may return nil if the implementation does not support one of the parameters, in which case a more general operation will be attempted.">PMatrixMultiply</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L430">430</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td></tr><tr class="pure-table-odd"><td><span title="Protocol for general inner and outer products of arrays. Products should use + and * as normally defined for numerical types">PMatrixProducts</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L438">438</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for add-product operation. Intended to implement a fast version for result = m + a * b">PAddProduct</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L444">444</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol for mutable add-product! operation.">PAddProductMutable</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L449">449</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for add-product operation. Intended to implement a fast version for result = m + a * b * factor">PAddScaledProduct</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L453">453</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol for mutable add-product! operation.">PAddScaledProductMutable</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L458">458</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for add-scaled operation. Intended to implement a fast version for result = m + a * factor">PAddScaled</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L462">462</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol for mutable add-scaled! operation.">PAddScaledMutable</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L467">467</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol to support element-wise division operator. One-arg version returns the reciprocal of all elements.">PMatrixDivide</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L471">471</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol to support mutable element-wise division operater. One-arg version returns the reciprocal of all elements.">PMatrixDivideMutable</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L478">478</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol to support mutable matrix multiplication on an arbitrary matrix, vector or scalar">PMatrixMultiplyMutable</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L485">485</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol to support transformation of a vector to another vector. Is equivalent to matrix multiplication when 2D matrices are used as transformations. But other transformations are possible, e.g. affine transformations. A transformation need not be a core.matrix matrix: other types are permissible">PVectorTransform</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L490">490</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td></tr><tr><td><span title="Protocol to support numerical array scaling by scalar values. Provided because array classes may have efficient specialised scaling operaions. Works according the the default definition of multiplication for the matrix class (usually numerical, i.e. equivalent to clojure.core/+)">PMatrixScaling</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L499">499</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td></tr><tr class="pure-table-odd"><td><span title="Protocol to support mutable array scaling by scalar values.">PMatrixMutableScaling</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L511">511</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol to support addition and subtraction on arbitrary matrices. These are elementwise operations that should support broadcasting.">PMatrixAdd</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L516">516</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td></tr><tr class="pure-table-odd"><td><span title="Protocol to support mutable addition and subtraction">PMatrixAddMutable</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L522">522</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol to get a subarray of another array. dim-ranges should be a sequence of [start len] pairs, one for each dimension. If a pair is nil, it should be interpreted to take the whole dimension. Returning a mutable view is preferred, if the implementation supports this.">PSubMatrix</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L527">527</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol to compute a matrix by calling a function on each indexed location. The function f will be called as (f x y z ...) for all index values.">PComputeMatrix</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L534">534</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for array transpose operation">PTranspose</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L539">539</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Rotates an array along a specified dimension by the given number of places. Rotating a dimension that does not exist has no effect on the array.">PRotate</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L548">548</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Rotates an array using the specified shifts for each dimension. shifts may be any sequence of iteger shift amounts.">PRotateAll</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L554">554</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol for mutable 2D matrix transpose in place">PTransposeInPlace</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L560">560</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for matrix reorder">POrder</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L565">565</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol for identifying numerical arrays. Should return true if every element in the array is a valid numerical value.">PNumerical</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L571">571</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol to support common numerical vector operations.">PVectorOps</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L577">577</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span>PVectorCross</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L595">595</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span>PVectorDistance</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L601">601</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span>PVectorView</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L605">605</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol to return an array as a flattened vector of all elements. Implementations are encouraged to avoid taking a full copy of all data (e.g. by using structural sharing or views).">PVectorisable</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L610">610</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol for mutable versions of common vector operations">PMutableVectorOps</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L618">618</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol to support common 2D numerical matrix operations">PMatrixOps</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L622">622</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td></tr><tr class="pure-table-odd"><td><span>PNegation</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L632">632</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol to support computing the rank (number of linearly independent rows) in a matrix">PMatrixRank</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L636">636</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol to support the summing of all elements in an array. The array must hold numeric values only, or an exception will be thrown.">PSummable</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L641">641</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td></tr><tr><td><span title="Protocol to support the &apos;pow&apos; function. Should raise every element of a matrix to a given exponent. Default implementation uses Java&apos;s Math/pow function which is appropriate for double values: arrays supporting arbitrary precision numbers or complex types will need to provide their own implementation.">PExponent</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L646">646</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol to support element-wise squaring of a numerical array.">PSquare</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L653">653</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for elementary row operations">PRowOperations</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L661">661</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol for row setting. Should set a dimension 0 (row) slice to thegiven row value.">PRowSetting</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L670">670</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for column setting. Should set a dimension 1 (column) slice to the given column value.">PColumnSetting</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L675">675</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol to return the total count of elements in matrix. Result may be any integer type, typically a java.lang.Long">PElementCount</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L692">692</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol to return the minimum and maximum elements in a numerical array. Must throw an exception if the array is not numerical.">PElementMinMax</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L697">697</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol to allow functional-style operations on matrix elements.">PFunctionalOperations</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L703">703</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td></tr><tr><td><span title="Protocol for matrix predicates like identity-matrix? or zero-matrix?">PMatrixPredicates</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L727">727</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span>PMatrixTypes</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L739">739</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for returning the generic/default values of a matrix implementation">PGenericValues</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L754">754</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol for returning the generic numerical functions of a matrix implementation">PGenericOperations</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L760">760</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for the sel function">PSelect</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L770">770</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol for setting the elements of an array returned by (select a args) to values">PSetSelection</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L774">774</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for getting elements of an array at the specified indices.">PIndicesAccess</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L778">778</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol for setting elements of an array at the specified indices">PIndicesSetting</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L782">782</a>)</small></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for getting non-zero indices of an array">PNonZeroIndices</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L787">787</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol for determining if an object is a valid index. Implementations may implement this protocol to support their own index types.">PIndexImplementation</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L793">793</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for matrix and vector norms">PNorm</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L805">805</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol for QR decomposition">PQRDecomposition</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L809">809</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Procotol for Cholesky decomposition">PCholeskyDecomposition</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L813">813</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol for LU decomposition">PLUDecomposition</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L817">817</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for SVD decomposition">PSVDDecomposition</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L821">821</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Procotol for Eigenvalue decomposition">PEigenDecomposition</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L825">825</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for solving linear matrix equation or system of linear scalar equations">PSolveLinear</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L829">829</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="Protocol for computing least-square solution to a linear matrix equation">PLeastSquares</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L833">833</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td><span title="Protocol for general dataset functionality">PDatasetImplementation</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L840">840</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><i class="icon-ok icon-large"></i></td><td style="text-align: center;"></td></tr><tr class="pure-table-odd"><td><span title="EXPERIMENTAL: Protocol for querying multi-dimensioned datasets">PDimensionImplementation</span>&nbsp;<small>(line <a href="https://github.com/mikera/core.matrix/blob//src/main/clojure/clojure/core/matrix/protocols.clj#L855">855</a>)</small></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table></div></div></body></html>